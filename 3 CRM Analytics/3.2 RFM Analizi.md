## RFM ile Müşteri Segmentasyonu (Customer Segmentation with RFM) 1

- RFM : **R**ecency, **F**requency, **M**onetary
- RFM Analizi müşteri segmentasyonu için kullanılan bir tekniktir.
- Müşterilerin satın alma alışkanlıkları üzerinden gruplara ayrılması ve bu gruplar özelinde stratejiler geliştirilebilmesini sağlar.
- CRM çalışmaları için birçok başlıkta veriye dayalı aksiyon alma imkanı sağlar.

#### RFM Metrikleri
##### Recency (Yenilik)
- Mesela bir müşterinin en son ne zaman alışveriş yaptığını gösterir. Recency değeri 1 olan bir müşteri ile 10 olan bir müşteriyi karşılaştırmamız gerekirse 1 olan bizim için daha önemlidir, çünkü en son 1 gün önce alışveriş yapmıştır.
##### Frequency (Sıklık)
- İşlem sayısıdır. Örneğin müşterinin yaptığı toplam alışveriş sayısıdır. 

##### Monetary (Parasal Değer)
- Müşterilerin bize bıraktığı parasal değeri ifade eder.

![[Ekran görüntüsü 2024-08-04 180727.png|550]]
Bu görselde müşterilerin RFM metrikleri bulunmaktadır. Ancak bu tabloda herhangi bir kısaylama yapamayacağım için bu metrikleri RFM skorlarına çevirmem gerekir.


#### RFM Skorları

RFM Skorları : Recency, frequency ve monetary ifadelerinin her birini aynı cinste ifade etmeye denir. Bir çeşit standartlaştırma işlemi yapacağız. Her biri kendi içinde ve birbirleri arasında kıyaslanabilir formata gelecek.
![[Ekran görüntüsü 2024-08-04 192653.png|550]]
Bu şekilde RFM metriklerini RFM skorlarına çevirmiş olduk. Ancak burada dikkat etmemiz gereken bir durum var. Recency değerlerinde en küçük rakama 5 değeri verildi, diğerlerinde en büyük rakama 5 değeri verildi.
![[Ekran görüntüsü 2024-08-04 193056.png|550]]
Bu ifadeleri string olarak birleştirerek RFM Skorlarını oluşturuyoruz.

![[Ekran görüntüsü 2024-08-04 193136.png|550]]

#### Skorlar Üzerinden Segmentler Oluşturmak

![[Ekran görüntüsü 2024-08-04 193501.png|750]]

Dikkat : Satırlarda Frequency değeri, sütunlarda ise Recency değeri var ama Monetary değeri nereye gitti? Çünkü bizimle etkileşim halinde olan bir müşteriye daha fazla satış gerçekleştirebiliriz. Bu yüzden Monetary değerine ihtiyaç duyulmamıştır. 

- Champions : Şampiyonlar, yani çok sık alışveriş yapanlar.
- Potential Loyalist : Sadık olma potansiyeli olanlar.
- New Customers : Yeni müşteriler.
- Promising : Umut verici olanlar.
- Loyal Customers : Sadık müşteriler.
- Need Attention : Dikkat edilmesi gereken müşteriler.
- About to sleep : Uykuda olan müşteriler.
- Can't Loose Them : Kaybetmememiz gereken müşteriler.
- At Risk : Risk altında olan müşteriler. Kaybedilmek üzere olanlar
- Hibernating : Kış uykusunda olan müşteriler.

## RFM ile Müşteri Segmentasyonu (Customer Segmentation with RFM) 2

- Yazılan kodlar aşağıdaki gibidir. Daha çok veriyi anlama üzerinde duruldu.

```python
###############################################################  
# RFM ile Müşteri Segmentasyonu (Customer Segmentation with RFM)  
###############################################################  
  
# 1. İş Problemi (Business Problem)  
# 2. Veriyi Anlama (Data Understanding)  
# 3. Veri Hazırlama (Data Preparation)  
# 4. RFM Metriklerinin Hesaplanması (Calculating RFM Metrics)  
# 5. RFM Skorlarının Hesaplanması (Calculating RFM Scores)  
# 6. RFM Segmentlerinin Oluşturulması ve Analiz Edilmesi (Creating & Analysing RFM Segments)  
# 7. Tüm Sürecin Fonksiyonlaştırılması  
  
###############################################################  
# 1. İş Problemi (Business Problem)  
###############################################################  
  
# Bir e-ticaret şirketi müşterilerini segmentlere ayırıp bu segmentlere göre  
# pazarlama stratejileri belirlemek istiyor.  
  
# Veri Seti Hikayesi  
# https://archive.ics.uci.edu/ml/datasets/Online+Retail+II  
  
# Online Retail II isimli veri seti İngiltere merkezli online bir satış mağazasının  
# 01/12/2009 - 09/12/2011 tarihleri arasındaki satışlarını içeriyor.  
  
# Değişkenler  
#  
# InvoiceNo: Fatura numarası. Her işleme yani faturaya ait eşsiz numara. C ile başlıyorsa iptal edilen işlem.  
# StockCode: Ürün kodu. Her bir ürün için eşsiz numara.  
# Description: Ürün ismi  
# Quantity: Ürün adedi. Faturalardaki ürünlerden kaçar tane satıldığını ifade etmektedir.  
# InvoiceDate: Fatura tarihi ve zamanı.  
# UnitPrice: Ürün fiyatı (Sterlin cinsinden)  
# CustomerID: Eşsiz müşteri numarası  
# Country: Ülke ismi. Müşterinin yaşadığı ülke.  
  
  
###############################################################  
# 2. Veriyi Anlama (Data Understanding)  
###############################################################  
  
import datetime as dt  
import pandas as pd  
pd.set_option('display.max_columns', None)  
pd.set_option('display.max_rows', None)  
pd.set_option('display.float_format', lambda x: '%.3f' % x)  
  
df_ = pd.read_excel(r"C:\Users\zbura\OneDrive\Masaüstü\CRM Analytics\3 CRM Analytics\Files\crmAnalytics\datasets\online_retail_II.xlsx", sheet_name="Year 2009-2010")  
df = df_.copy()  
df.head()  
df.shape  
df.isnull().sum()  
  
# Essiz urun sayisi nedir?  
df["Description"].nunique()  
  
# Hangi urunden kacar tane satilmis?  
df["Description"].value_counts().head()  
  
# En cok siparis edilen urun hangisidir?  
# Not: quantity oldugu icin gruplamak gerekiyor  
df.groupby("Description").agg({"Quantity": "sum"}).head() # problemli bir sonuc cikti, ileride cozulecek.  
  
# Toplam satislari quantity'ye gore buyukten kucuge siralama  
df.groupby("Description").agg({"Quantity": "sum"}).sort_values("Quantity", ascending=False).head()  
  
df["Invoice"].nunique()  
  
# Her urun toplam ne kadar kazandirmistir?  
df["TotalPrice"] = df["Quantity"] * df["Price"]  
df.head()  
  
# Fatura basina toplam kac para kazanilmistir?  
df.groupby("Invoice").agg({"TotalPrice": "sum"}).head()
```

## Veriyi Hazırlama (Data Preparation)

```python
import datetime as dt  
import pandas as pd  
pd.set_option('display.max_columns', None)  
pd.set_option('display.max_rows', None)  
pd.set_option('display.float_format', lambda x: '%.3f' % x)  
  
df_ = pd.read_excel(r"C:\Users\zbura\OneDrive\Masaüstü\CRM Analytics\3 CRM Analytics\Files\crmAnalytics\datasets\online_retail_II.xlsx", sheet_name="Year 2009-2010")  
df = df_.copy()  
  
df.groupby("Invoice").agg({"TotalPrice": "sum"}).head()  
  
###############################################################  
# 3. Veri Hazırlama (Data Preparation)  
###############################################################  
df.shape  
df.isnull().sum()  
df.dropna(inplace=True)  
# Dropna Eksik degerleri siler. inplace ise bu islemin df tablosu uzerinde gerceklesmesini saglar.  
df.shape  
df.describe().T  
  
df = df[~df["Invoice"].str.contains("C", na=False)]  
# Invoice ifadelerinde basinda C olmayanlari getirir. Eger '~' ifadesini koymazsak sadece basinda C olanlari getirir.
```
## RFM Metriklerinin Hesaplanması (Calculating RFM Metrics)

```python
# Recency, Frequency, Monetary  
  
# Recency : Musterinin yeniligi, sicakligi. ((Analizin yapildigi tarih)-(Musterinin alisveris yaptigi tarih))  
# Frequency : Musterinin yaptigi toplam satin alma  
# Monetary : Musterinin yaptigi toplam satin almalar neticesinde biraktigi parasal deger.  
df.head()  
  
# verisetimiz 2009-2011 yillari arasinda gecmektedir. Biz o donemde yasamadigimiz icin analizin yapildigi gunu herhangi  
# bir gun olarak bir degiskene atamamiz gerekmektedir.  
  
df["InvoiceDate"].max()  
# burada son fatura tarihini bulduk ve asagide ise bu tarihten 2 gun sonrasini baz alacagimizi soyleyecegiz.  
  
today_date = dt.datetime(2010, 12, 11)  
type(today_date)  
  
rfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda date: (today_date - date.max()).days,  
                                     'Invoice': lambda num: num.nunique(),  
                                     'TotalPrice': lambda TotalPrice: TotalPrice.sum()})  
  
rfm.head()  
rfm.columns = ['recency', 'frequency', 'monetary']  
rfm.describe().T  
# Bu ifade icerisinde monetary degeri 0 olan satirlar da oldugu icin bunlari almamaya karar verdik.  
  
rfm = rfm[rfm["monetary"] > 0] # monetary degeri 0 dan buyuk olan tum satirlari sec dedik.  
rfm.describe().T  
rfm.shape # Yeni verisetimizdeki musteri sayimiz.
```
